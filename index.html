<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viewer</title>
    <link rel="stylesheet" href="styles.css">
    <!-- Load configuration first -->
    <script src="config.js"></script>
    <script src="advanced-config.js"></script>
    <script src="https://unpkg.com/deck.gl@8.8.27/dist.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-dsv@3"></script>
    <script src="https://unpkg.com/d3-array@3"></script>
    <!-- Import the polygon boundary highlighter -->
    <script src="modules/polygon-boundary-highlighter.js"></script>
    <!-- Import glyph helpers -->
    <script src="modules/glyphPaths.js"></script>
    <script src="modules/glyphConfig.js"></script>
    <!-- Import cell class configuration -->
    <script src="modules/classConfig.js"></script>
    <!-- Import cell lookup module -->
    <script src="modules/cellLookup.js"></script>
</head>
<body>
    <div id="map"></div>
    <div id="tooltip"></div>


    <!-- Cell Search Modal -->
    <div class="cell-search-modal" id="cellSearchModal">
        <div class="cell-search-dialog">
            <h3>üîç Cell Lookup</h3>
            <input type="text" class="cell-search-input" id="cellSearchInput" placeholder="Enter cell ID (e.g., 1, 42, 1000...)" />
            <div class="cell-search-buttons">
                <button class="cell-search-btn primary" id="cellSearchGo">Go to Cell</button>
                <button class="cell-search-btn secondary" id="cellSearchCancel">Cancel</button>
            </div>
            <div class="cell-search-status" id="cellSearchStatus"></div>
        </div>
    </div>

    <!-- Gene Panel Button with Size Slider -->
    <div class="minimal-controls" style="top: 15px; left: 15px; right: auto;">
        <button id="genePanelBtn">üß¨ Genes</button>
        <div class="control-item gene-size-item">
            <label for="geneSizeSlider">Size</label>
            <input type="range" id="geneSizeSlider" min="0.5" max="3.0" step="0.1" value="1.0">
            <span id="geneSizeValue">1.0</span>
        </div>
    </div>

    <!-- Cell Class Panel Button -->
    <div class="minimal-controls" style="top: 70px; right: 15px; left: auto;">
        <button id="cellClassPanelBtn">üî¨ Cell Classes</button>
    </div>

    <!-- Floating Gene Panel Widget -->
    <div id="geneWidget" class="gene-widget hidden">
        <div class="gene-widget-header">
            <span class="gene-widget-title">üß¨ Gene Panel</span>
            <div class="widget-header-buttons">
                <button id="geneWidgetUndock" class="widget-undock-btn" title="Open in separate window">‚ßâ</button>
                <button id="geneWidgetClose" class="widget-close-btn">√ó</button>
            </div>
        </div>
        <div class="gene-widget-search">
            <input type="text" id="geneSearch" placeholder="Search genes..." />
            <button id="toggleAllGenes" class="toggle-all-btn">Unselect All</button>
        </div>
        <div class="gene-widget-content" id="geneList">
            <!-- Gene list will be populated here -->
        </div>
    </div>

    <!-- Floating Cell Class Panel Widget -->
    <div id="cellClassWidget" class="gene-widget hidden" style="top: 100px; right: 20px; left: auto;">
        <div class="gene-widget-header">
            <span class="gene-widget-title">üî¨ Cell Class Panel</span>
            <div class="widget-header-buttons">
                <button id="cellClassWidgetUndock" class="widget-undock-btn" title="Open in separate window">‚ßâ</button>
                <button id="cellClassWidgetClose" class="widget-close-btn">√ó</button>
            </div>
        </div>
        <div class="gene-widget-search">
            <input type="text" id="cellClassSearch" placeholder="Search cell classes..."/>
            <button id="toggleAllCellClasses" class="toggle-all-btn">Unselect All</button>
        </div>
        <div class="gene-widget-content" id="cellClassList">
            <!-- Cell class list will be populated here -->
        </div>
    </div>

    <!-- Widget overlay backdrop -->
    <div id="geneWidgetBackdrop" class="widget-backdrop hidden"></div>
    <div id="cellClassWidgetBackdrop" class="widget-backdrop hidden"></div>

    <!-- Main Controls -->
    <div class="main-controls">
        <button class="nav-btn" id="prevBtn">‚óÑ</button>
        <input type="range" id="planeSlider" min="0" max="99" value="50">
        <button class="nav-btn" id="nextBtn">‚ñ∫</button>
        <span id="planeLabel">Plane: 50</span>
    </div>

    <!-- Minimal Layer Controls -->
    <div class="minimal-controls" id="layerControls">
        <div class="control-item">
            <input type="checkbox" id="showTiles" checked>
            <label for="showTiles">Dapi</label>
        </div>
        <div class="control-item">
            <input type="checkbox" id="showPolygons" checked>
            <label for="showPolygons">Cells</label>
        </div>
        <div class="control-item polygon-opacity-item">
            <label for="polygonOpacitySlider">Opacity</label>
            <input type="range" id="polygonOpacitySlider" min="0.0" max="1.0" step="0.1">
            <span id="polygonOpacityValue">0.4</span>
        </div>
    </div>

    <div class="loading-indicator" id="loadingIndicator">Loading...</div>
    
    <!-- Scale Bar -->
    <div id="scaleBar" class="scale-bar">
        <div class="scale-bar-line"></div>
        <div class="scale-bar-label">100 Œºm</div>
    </div>
    
    <!-- Coordinate Display -->
    <div id="coordinateDisplay" class="coordinate-display" style="display: none;">
        <span id="pixelCoords">---, ---</span> px | 
        <span id="micronCoords">---, ---</span> Œºm | 
        <span id="deckglCoords">---, ---</span> deck
    </div>

    <script type="module">
        // Import configuration constants
        import {
            INITIAL_VIEW_STATE,
            MAX_PRELOAD,
            DEFAULT_STATE,
            UI_ELEMENTS
        } from './config/constants.js';

        // Import coordinate transformation utilities
        import {
            clamp
        } from './utils/coordinateTransform.js';

        // Import data loading functions
        import {
            loadGeneData,
            loadPolygonData,
            loadCellData,
            assignColorsToCellClasses,
            buildGeneSpotIndexes
        } from './modules/dataLoaders.js';

        // Import layer creation functions
        import {
            createTileLayer,
            createPolygonLayers,
            createGeneLayers
        } from './modules/layerCreators.js';

        // Import UI helper functions
        import {
            showLoading,
            hideLoading,
            showTooltip
        } from './modules/uiHelpers.js';

        // Import event handling functions
        import {
            setupEventHandlers,
            setupAdvancedKeyboardShortcuts
        } from './modules/eventHandlers.js';

        // Extract deck.gl components
        const {DeckGL, OrthographicView, COORDINATE_SYSTEM} = deck;

        // Application state
        const state = {
            currentPlane: DEFAULT_STATE.currentPlane,
            deckglInstance: null,
            isLoading: false,
            
            // Layer visibility
            showTiles: DEFAULT_STATE.showTiles,
            showPolygons: DEFAULT_STATE.showPolygons,
            showGenes: DEFAULT_STATE.showGenes,
            
            // Data caches
            tileCache: new Map(),
            polygonCache: new Map(),
            geneDataMap: new Map(),
            cellDataMap: new Map(),
            
            // Lightning-fast lookup indexes
            cellToSpotsIndex: new Map(), // cellLabel -> array of spots (O(1) lookup)
            spotToParentsIndex: new Map(), // spotId -> parent info (O(1) lookup)
            
            // Layer persistence for better performance
            tileLayers: new Map(), // Cache tile layer instances
            
            // Performance tracking
            polygonLoadTimes: new Map(),
            lastCleanupTime: Date.now(),
            
            // Cell class data for coloring (no filtering, just colors)
            cellClassColors: new Map(),
            allCellClasses: new Set(),
            selectedCellClasses: new Set(), // For filtering visibility
            
            // Gene data
            selectedGenes: new Set(),
            geneIconAtlas: null,
            geneIconMapping: null,
            geneSizeScale: DEFAULT_STATE.geneSizeScale,
            
            // Polygon opacity
            polygonOpacity: DEFAULT_STATE.polygonOpacity,
            
            // Interactions
            polygonHighlighter: null,
            genePanelWin: null
        };

        // Expose state globally for cell lookup module
        window.appState = state;

        // === DEBUG/CONSOLE ACCESS ===
        // Expose data for console access and debugging
        window.debugData = {
            // Raw data access
            geneData: () => state.geneDataMap,
            cellData: () => state.cellDataMap,
            boundaries: () => state.polygonCache,
            
            // Helper functions for common queries
            getGeneSpots: (geneName) => state.geneDataMap.get(geneName),
            getCell: (cellNum) => state.cellDataMap.get(cellNum),
            getBoundaries: (planeNum) => state.polygonCache.get(planeNum),
            
            // ‚ö° LIGHTNING-FAST LOOKUPS ‚ö°
            // Get all spots for a specific parent cell (O(1) lookup)
            getSpotsForCell: (cellLabel) => {
                return state.cellToSpotsIndex.get(cellLabel) || [];
            },
            
            // Get parent info for a specific spot (O(1) lookup)
            getParentsForSpot: (spot_id) => {
                return state.spotToParentsIndex.get(spot_id) || null;
            },
            
            // Summary functions
            listGenes: () => Array.from(state.geneDataMap.keys()),
            listCells: () => Array.from(state.cellDataMap.keys()),
            listPlanes: () => Array.from(state.polygonCache.keys()),
            
            // Statistics
            geneCount: () => state.geneDataMap.size,
            cellCount: () => state.cellDataMap.size,
            planesLoaded: () => state.polygonCache.size,
            indexStats: () => ({
                cellsIndexed: state.cellToSpotsIndex.size,
                spotsIndexed: state.spotToParentsIndex.size
            }),
            
            // Current state
            currentPlane: () => state.currentPlane,
            appState: () => state
        };

        // DOM elements
        const elements = {
            slider: document.getElementById(UI_ELEMENTS.planeSlider),
            label: document.getElementById(UI_ELEMENTS.planeLabel),
            prevBtn: document.getElementById(UI_ELEMENTS.prevBtn),
            nextBtn: document.getElementById(UI_ELEMENTS.nextBtn),
            loadingIndicator: document.getElementById(UI_ELEMENTS.loadingIndicator),
            
            // Layer controls
            showTiles: document.getElementById(UI_ELEMENTS.showTiles),
            showPolygons: document.getElementById(UI_ELEMENTS.showPolygons),
            
            // Polygon controls
            polygonOpacitySlider: document.getElementById(UI_ELEMENTS.polygonOpacitySlider),
            polygonOpacityValue: document.getElementById(UI_ELEMENTS.polygonOpacityValue),
            
            // Gene controls
            geneSizeSlider: document.getElementById(UI_ELEMENTS.geneSizeSlider),
            geneSizeValue: document.getElementById(UI_ELEMENTS.geneSizeValue),
            genePanelBtn: document.getElementById(UI_ELEMENTS.genePanelBtn),
            
            // Gene widget
            geneWidget: document.getElementById('geneWidget'),
            geneWidgetBackdrop: document.getElementById('geneWidgetBackdrop'),
            geneWidgetClose: document.getElementById('geneWidgetClose'),
            geneWidgetUndock: document.getElementById('geneWidgetUndock'),
            geneSearch: document.getElementById('geneSearch'),
            geneList: document.getElementById('geneList'),
            toggleAllGenes: document.getElementById('toggleAllGenes'),
            
            // Cell class widget
            cellClassPanelBtn: document.getElementById('cellClassPanelBtn'),
            cellClassWidget: document.getElementById('cellClassWidget'),
            cellClassWidgetBackdrop: document.getElementById('cellClassWidgetBackdrop'),
            cellClassWidgetClose: document.getElementById('cellClassWidgetClose'),
            cellClassWidgetUndock: document.getElementById('cellClassWidgetUndock'),
            cellClassSearch: document.getElementById('cellClassSearch'),
            cellClassList: document.getElementById('cellClassList'),
            toggleAllCellClasses: document.getElementById('toggleAllCellClasses'),
            
            // UI
            layerControls: document.getElementById(UI_ELEMENTS.layerControls),
            tooltip: document.getElementById(UI_ELEMENTS.tooltip)
        };

        // === GENE WIDGET FUNCTIONS ===
        
        function createGeneGlyph(glyphName, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 20;
            canvas.height = 20;
            canvas.className = 'gene-glyph';
            
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, 20, 20);
            
            const p = {x: 10, y: 10};
            const r = ['star5','star6'].includes(glyphName) ? 9 : 7;
            
            ctxPath(glyphName, ctx, p, r);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            return canvas;
        }
        
        function populateGeneWidget() {
            const geneList = elements.geneList;
            geneList.innerHTML = '';
            
            const genes = Array.from(state.geneDataMap.keys()).sort();
            
            genes.forEach(gene => {
                const cfg = glyphSettings().find(d => d.gene === gene) ||
                           glyphSettings().find(d => d.gene === 'Generic');
                
                const item = document.createElement('div');
                item.className = 'gene-item';
                item.dataset.gene = gene;
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'gene-checkbox';
                checkbox.checked = state.selectedGenes.has(gene);
                checkbox.addEventListener('change', () => toggleGene(gene, checkbox.checked));
                
                const glyph = createGeneGlyph(cfg.glyphName, cfg.color);
                
                const name = document.createElement('span');
                name.className = 'gene-name';
                const spotCount = state.geneDataMap.get(gene)?.length || 0;
                name.textContent = `${gene} (${spotCount.toLocaleString()})`;
                
                item.appendChild(checkbox);
                item.appendChild(glyph);
                item.appendChild(name);
                
                geneList.appendChild(item);
            });
            
            updateToggleAllButton();
        }
        
        function toggleGene(gene, isVisible) {
            if (isVisible) {
                state.selectedGenes.add(gene);
            } else {
                state.selectedGenes.delete(gene);
            }
            updateAllLayers();
            updateToggleAllButton();
        }
        
        function updateToggleAllButton() {
            const totalGenes = state.geneDataMap.size;
            const selectedGenes = state.selectedGenes.size;
            const btn = elements.toggleAllGenes;
            
            if (selectedGenes === totalGenes) {
                btn.textContent = 'Unselect All';
                btn.className = 'toggle-all-btn unselect';
            } else {
                btn.textContent = 'Select All';
                btn.className = 'toggle-all-btn';
            }
        }
        
        function toggleAllGenes() {
            const totalGenes = state.geneDataMap.size;
            const selectedGenes = state.selectedGenes.size;
            const shouldSelectAll = selectedGenes < totalGenes;
            
            if (shouldSelectAll) {
                // Select all genes
                state.geneDataMap.forEach((_, gene) => {
                    state.selectedGenes.add(gene);
                });
            } else {
                // Unselect all genes
                state.selectedGenes.clear();
            }
            
            // Update all checkboxes in the widget
            const checkboxes = elements.geneList.querySelectorAll('.gene-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = shouldSelectAll;
            });
            
            updateAllLayers();
            updateToggleAllButton();
        }
        
        function showGeneWidget() {
            elements.geneWidget.classList.remove('hidden');
            elements.geneWidgetBackdrop.classList.remove('hidden');
            populateGeneWidget();
            setupDragFunctionality();
        }
        
        function setupDragFunctionality() {
            const widget = elements.geneWidget;
            const header = widget.querySelector('.gene-widget-header');
            let isDragging = false;
            let currentX = 0;
            let currentY = 0;
            let initialX = 0;
            let initialY = 0;
            
            function dragStart(e) {
                // Don't drag if clicking on buttons
                if (e.target.tagName === 'BUTTON') return;
                
                if (e.target === header || header.contains(e.target)) {
                    isDragging = true;
                    widget.classList.add('dragging');
                    
                    // Get current position
                    const rect = widget.getBoundingClientRect();
                    
                    if (e.type === 'touchstart') {
                        initialX = e.touches[0].clientX - rect.left;
                        initialY = e.touches[0].clientY - rect.top;
                    } else {
                        initialX = e.clientX - rect.left;
                        initialY = e.clientY - rect.top;
                    }
                }
            }
            
            function dragEnd(e) {
                if (isDragging) {
                    isDragging = false;
                    widget.classList.remove('dragging');
                }
            }
            
            function drag(e) {
                if (!isDragging) return;
                
                e.preventDefault();
                
                if (e.type === 'touchmove') {
                    currentX = e.touches[0].clientX - initialX;
                    currentY = e.touches[0].clientY - initialY;
                } else {
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                }
                
                // Constrain to viewport
                const maxX = window.innerWidth - widget.offsetWidth;
                const maxY = window.innerHeight - widget.offsetHeight;
                
                const newX = Math.max(0, Math.min(currentX, maxX));
                const newY = Math.max(0, Math.min(currentY, maxY));
                
                widget.style.left = newX + 'px';
                widget.style.top = newY + 'px';
                widget.style.transform = 'none';
            }
            
            // Mouse events
            header.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);
            
            // Touch events for mobile
            header.addEventListener('touchstart', dragStart);
            document.addEventListener('touchmove', drag);
            document.addEventListener('touchend', dragEnd);
        }
        
        function hideGeneWidget() {
            elements.geneWidget.classList.add('hidden');
            elements.geneWidgetBackdrop.classList.add('hidden');
            elements.geneWidget.classList.remove('dragging');
            
            // Reset position for next time
            elements.geneWidget.style.left = '20px';
            elements.geneWidget.style.top = '20px';
            elements.geneWidget.style.transform = 'translateX(0)';
        }
        
        function filterGenes(searchTerm) {
            const items = elements.geneList.querySelectorAll('.gene-item');
            items.forEach(item => {
                const geneName = item.dataset.gene.toLowerCase();
                const matches = geneName.includes(searchTerm.toLowerCase());
                item.style.display = matches ? 'flex' : 'none';
            });
        }
        
        function undockGeneWidget() {
            // Hide the floating widget
            hideGeneWidget();
            
            // Open the separate gene panel window
            const genePanelWindow = window.open('genes_datatable.html', 'genePanel', 
                'width=500,height=600,scrollbars=yes,resizable=yes');
            
            if (genePanelWindow) {
                // Store reference for communication
                state.genePanelWin = genePanelWindow;
                
                // Send gene list when window is ready
                genePanelWindow.addEventListener('load', () => {
                    const genes = Array.from(state.geneDataMap.keys());
                    const chosen = Array.from(state.selectedGenes);
                    genePanelWindow.postMessage({
                        type: 'geneList',
                        genes: genes,
                        chosen: chosen
                    }, '*');
                });
            }
        }
        
        // Expose functions globally for event handlers
        window.showGeneWidget = showGeneWidget;
        window.hideGeneWidget = hideGeneWidget;
        window.filterGenes = filterGenes;
        window.toggleAllGenes = toggleAllGenes;
        window.undockGeneWidget = undockGeneWidget;
        
        // Cell class widget functions
        window.showCellClassWidget = showCellClassWidget;
        window.hideCellClassWidget = hideCellClassWidget;
        window.filterCellClasses = filterCellClasses;
        window.toggleAllCellClasses = toggleAllCellClasses;
        window.undockCellClassWidget = undockCellClassWidget;
        
        // === CELL CLASS WIDGET FUNCTIONS ===
        function populateCellClassWidget() {
            if (!state.allCellClasses || state.allCellClasses.size === 0) {
                elements.cellClassList.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No cell classes available</div>';
                return;
            }
            
            const cellClasses = Array.from(state.allCellClasses).sort();
            console.log(`Populating cell class widget with ${cellClasses.length} classes:`, cellClasses);
            
            // Don't modify selectedCellClasses here - preserve the current state
            
            elements.cellClassList.innerHTML = '';
            
            cellClasses.forEach(cellClass => {
                const item = document.createElement('div');
                item.className = 'gene-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'gene-checkbox';
                checkbox.checked = state.selectedCellClasses.has(cellClass);
                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) {
                        state.selectedCellClasses.add(cellClass);
                    } else {
                        state.selectedCellClasses.delete(cellClass);
                    }
                    console.log(`Cell class ${cellClass} toggled to ${checkbox.checked}`);
                    console.log(`Selected cell classes:`, Array.from(state.selectedCellClasses));
                    updateAllLayers();
                    updateToggleAllCellClassesButton();
                });
                
                const colorSwatch = document.createElement('div');
                colorSwatch.className = 'gene-glyph';
                const color = state.cellClassColors.get(cellClass) || [192, 192, 192];
                colorSwatch.style.backgroundColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                
                const name = document.createElement('span');
                name.className = 'gene-name';
                name.textContent = cellClass;
                
                item.appendChild(checkbox);
                item.appendChild(colorSwatch);
                item.appendChild(name);
                
                elements.cellClassList.appendChild(item);
            });
            
            updateToggleAllCellClassesButton();
        }
        
        function updateToggleAllCellClassesButton() {
            const allSelected = state.selectedCellClasses.size === state.allCellClasses.size;
            elements.toggleAllCellClasses.textContent = allSelected ? 'Unselect All' : 'Select All';
            elements.toggleAllCellClasses.className = allSelected ? 'toggle-all-btn unselect' : 'toggle-all-btn';
        }
        
        function toggleAllCellClasses() {
            const shouldSelectAll = state.selectedCellClasses.size !== state.allCellClasses.size;
            
            console.log(`Toggle all cell classes: shouldSelectAll = ${shouldSelectAll}`);
            console.log(`Before: selectedCellClasses.size = ${state.selectedCellClasses.size}, allCellClasses.size = ${state.allCellClasses.size}`);
            
            if (shouldSelectAll) {
                state.allCellClasses.forEach(cellClass => state.selectedCellClasses.add(cellClass));
            } else {
                state.selectedCellClasses.clear();
            }
            
            console.log(`After: selectedCellClasses.size = ${state.selectedCellClasses.size}`);
            console.log(`Selected cell classes:`, Array.from(state.selectedCellClasses));
            
            // Update all checkboxes in the widget
            const checkboxes = elements.cellClassList.querySelectorAll('.gene-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = shouldSelectAll;
            });
            
            updateAllLayers();
            updateToggleAllCellClassesButton();
        }
        
        function showCellClassWidget() {
            elements.cellClassWidget.classList.remove('hidden');
            elements.cellClassWidgetBackdrop.classList.remove('hidden');
            populateCellClassWidget();
            setupCellClassDragFunctionality();
        }
        
        function hideCellClassWidget() {
            elements.cellClassWidget.classList.add('hidden');
            elements.cellClassWidgetBackdrop.classList.add('hidden');
        }
        
        function setupCellClassDragFunctionality() {
            const widget = elements.cellClassWidget;
            const header = widget.querySelector('.gene-widget-header');
            let isDragging = false;
            let currentX = window.innerWidth - 420; // Start from right side
            let currentY = 100; // Start from top
            let initialX = 0;
            let initialY = 0;
            
            // Set initial position
            widget.style.left = currentX + 'px';
            widget.style.top = currentY + 'px';
            
            function dragStart(e) {
                if (e.target.tagName === 'BUTTON') return;
                
                initialX = e.clientX - currentX;
                initialY = e.clientY - currentY;
                
                if (e.target === header || header.contains(e.target)) {
                    isDragging = true;
                    widget.classList.add('dragging');
                }
            }
            
            function dragEnd() {
                isDragging = false;
                widget.classList.remove('dragging');
            }
            
            function drag(e) {
                if (isDragging) {
                    e.preventDefault();
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                    
                    widget.style.left = currentX + 'px';
                    widget.style.top = currentY + 'px';
                }
            }
            
            header.addEventListener('mousedown', dragStart);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);
        }
        
        function undockCellClassWidget() {
            // Create a new window with the cell class list
            const newWindow = window.open('', 'CellClassPanel', 'width=450,height=600,scrollbars=yes');
            
            if (newWindow) {
                newWindow.document.write(`
                    <html>
                        <head>
                            <title>Cell Class Panel</title>
                            <style>
                                ${document.querySelector('style') ? document.querySelector('style').innerHTML : ''}
                                body { margin: 0; padding: 20px; background: #1a1a1a; color: white; font-family: Arial, sans-serif; }
                                .gene-widget-content { max-height: none; overflow-y: auto; }
                            </style>
                        </head>
                        <body>
                            <h3>üî¨ Cell Class Panel</h3>
                            <div class="gene-widget-content" id="undockedCellClassList"></div>
                            <script>
                                // Copy the current cell class list content
                                document.getElementById('undockedCellClassList').innerHTML = ${JSON.stringify(elements.cellClassList.innerHTML)};
                                
                                // Add event listeners to the new checkboxes
                                const checkboxes = document.querySelectorAll('.gene-checkbox');
                                checkboxes.forEach((checkbox, index) => {
                                    checkbox.addEventListener('change', () => {
                                        // Send message back to parent window
                                        window.opener.postMessage({
                                            type: 'cellClassToggle',
                                            index: index,
                                            checked: checkbox.checked
                                        }, '*');
                                    });
                                });
                            <\/script>
                        </body>
                    </html>
                `);
                newWindow.document.close();
                
                // Listen for messages from the undocked window
                window.addEventListener('message', (event) => {
                    if (event.data.type === 'cellClassToggle') {
                        const checkboxes = elements.cellClassList.querySelectorAll('.gene-checkbox');
                        const checkbox = checkboxes[event.data.index];
                        if (checkbox) {
                            checkbox.checked = event.data.checked;
                            checkbox.dispatchEvent(new Event('change'));
                        }
                    }
                });
                
                hideCellClassWidget();
            }
        }
        
        function filterCellClasses(searchTerm) {
            const items = elements.cellClassList.querySelectorAll('.gene-item');
            const term = searchTerm.toLowerCase();
            
            items.forEach(item => {
                const cellClassName = item.querySelector('.gene-name').textContent.toLowerCase();
                if (cellClassName.includes(term)) {
                    item.style.display = 'flex';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        // === UTILITY FUNCTIONS ===
        // Utility functions have been moved to modules/uiHelpers.js and modules/dataLoaders.js


        // === GENE DATA FUNCTIONS ===
        // Gene data loading functions have been moved to modules/dataLoaders.js

        // === POLYGON DATA FUNCTIONS ===
        // Polygon data loading functions have been moved to modules/dataLoaders.js

        // === LAYER CREATION FUNCTIONS ===
        // Layer creation functions have been moved to modules/layerCreators.js

        // === SCALE BAR FUNCTIONS ===
        function calculateScaleBar(viewState) {
            const config = window.config();
            const voxelSize = config.voxelSize;
            const resolution = voxelSize[0]; // microns per pixel in original image
            
            // Deck.gl coordinate system: image is mapped to 256x256 coordinate space
            // So 1 deck.gl unit = imageWidth/256 image pixels
            const deckglUnitsPerImagePixel = 256 / config.imageWidth;
            
            // Convert from deck.gl coordinates to microns
            // 1 deck.gl unit = (imageWidth/256) image pixels = (imageWidth/256) * resolution microns
            const micronsPerDeckglUnit = (config.imageWidth / 256) * resolution;
            
            // Account for zoom level
            const micronsPerPixel = micronsPerDeckglUnit / Math.pow(2, viewState.zoom);
            const pixelsPerMicron = 1 / micronsPerPixel;
            
            // Choose appropriate scale length
            const scaleOptions = [0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000]; // Œºm
            const targetPixels = 100; // Target scale bar length in pixels
            
            let bestScale = scaleOptions[0];
            for (const scale of scaleOptions) {
                const pixels = scale / micronsPerPixel;
                if (pixels <= targetPixels && pixels >= 40) { // Min 40px for readability
                    bestScale = scale;
                } else if (pixels > targetPixels) {
                    break;
                }
            }
            
            const actualPixels = bestScale / micronsPerPixel;
            return { pixels: actualPixels, distance: bestScale };
        }
        
        function formatDistance(microns) {
            if (microns < 1) {
                return `${(microns * 1000).toFixed(0)} nm`;
            } else if (microns < 1000) {
                return `${microns} Œºm`;
            } else {
                return `${(microns / 1000).toFixed(1)} mm`;
            }
        }
        
        function updateScaleBar(viewState) {
            const scaleBar = document.getElementById('scaleBar');
            const scaleLine = scaleBar.querySelector('.scale-bar-line');
            const scaleLabel = scaleBar.querySelector('.scale-bar-label');
            
            if (!scaleBar || !scaleLine || !scaleLabel) return;
            
            const { pixels, distance } = calculateScaleBar(viewState);
            
            // Update scale bar appearance
            scaleLine.style.width = pixels + 'px';
            scaleLabel.textContent = formatDistance(distance);
            
            // Add some debug info
            console.log(`Scale bar: ${formatDistance(distance)} = ${pixels.toFixed(1)}px at zoom ${viewState.zoom.toFixed(1)}`);
        }
        
        // === COORDINATE DISPLAY FUNCTIONS ===
        function updateCoordinateDisplay(info) {
            const coordDisplay = document.getElementById('coordinateDisplay');
            if (!coordDisplay) return;
            
            if (info.coordinate) {
                const config = window.config();
                const [deckX, deckY] = info.coordinate;
                
                // Convert deck.gl coordinates to image pixels
                // deck.gl (256, 256) should map to image (6411, 6411) if image is 6411x4412 for example
                const longSide = Math.max(config.imageWidth, config.imageHeight);
                const imageX = deckX * longSide / 256;
                const imageY = deckY * longSide / 256;
                
                // Convert to microns
                const [xVoxel, yVoxel, zVoxel] = config.voxelSize;
                const micronX = imageX * xVoxel;
                const micronY = imageY * yVoxel;
                
                // Update display elements
                document.getElementById('pixelCoords').textContent = 
                    `${Math.round(imageX)}, ${Math.round(imageY)}`;
                document.getElementById('micronCoords').textContent = 
                    `${micronX.toFixed(1)}, ${micronY.toFixed(1)}`;
                document.getElementById('deckglCoords').textContent = 
                    `${deckX.toFixed(2)}, ${deckY.toFixed(2)}`;
                    
                coordDisplay.style.display = 'block';
            } else {
                coordDisplay.style.display = 'none';
            }
        }

        // === DEBUG FUNCTIONS ===
        function createDebugDots() {
            const config = window.config();
            
            // Define pixel coordinates for the four corners
            const pixelCoords = [
                [0, 0],           // Top-left
                [0, 4412],        // Bottom-left  
                [6411, 4412],     // Bottom-right
                [6411, 0]         // Top-right
            ];
            
            // Convert pixel coordinates to deck.gl coordinates
            const longSide = Math.max(config.imageWidth, config.imageHeight);
            const debugPoints = pixelCoords.map(([x, y], index) => ({
                position: [x * 256 / longSide, y * 256 / longSide],
                color: [255, 0, 0], // Bright red
                radius: 0.5, // 0.5 pixel radius = 1 pixel diameter
                id: index
            }));
            
            return new deck.ScatterplotLayer({
                id: 'debug-dots',
                data: debugPoints,
                getPosition: d => d.position,
                getRadius: d => d.radius,
                getFillColor: d => d.color,
                radiusUnits: 'pixels',
                pickable: true,
                radiusMinPixels: 0.5,
                radiusMaxPixels: 0.5
            });
        }

        // === MAIN UPDATE FUNCTION ===
        function updateAllLayers() {
            if (!state.deckglInstance) return;

            const layers = [];

            // Add tile layers - keep same instances, only change opacity
            const direction = elements.slider.value > state.currentPlane ? 1 : -1;
            const preloadAhead = direction === 1 ? MAX_PRELOAD + 1 : MAX_PRELOAD;
            const preloadBehind = direction === -1 ? MAX_PRELOAD + 1 : MAX_PRELOAD;

            const userConfig = window.config();
            const start = Math.max(0, state.currentPlane - preloadBehind);
            const end = Math.min(userConfig.totalPlanes - 1, state.currentPlane + preloadAhead);

            for (let plane = start; plane <= end; plane++) {
                const opacity = plane === state.currentPlane ? 1 : 0;
                const layerId = `tiles-${plane}`;
                
                // Reuse existing layer instance or create new one
                let tileLayer = state.tileLayers.get(layerId);
                if (!tileLayer) {
                    tileLayer = createTileLayer(plane, opacity, state.tileCache, state.showTiles);
                    state.tileLayers.set(layerId, tileLayer);
                } else {
                    // Update existing layer's opacity and visibility
                    tileLayer = tileLayer.clone({
                        opacity: opacity,
                        visible: state.showTiles
                    });
                    state.tileLayers.set(layerId, tileLayer);
                }
                
                layers.push(tileLayer);
            }

            // Add polygon layers for current plane ONLY if cached
            if (state.polygonCache.has(state.currentPlane)) {
                layers.push(...createPolygonLayers(
                    state.currentPlane, 
                    state.polygonCache, 
                    state.showPolygons, 
                    state.cellClassColors, 
                    state.polygonOpacity,
                    state.selectedCellClasses
                ));
            }

            // Add gene layers
            layers.push(...createGeneLayers(state.geneDataMap, state.showGenes, state.selectedGenes, state.geneIconAtlas, state.geneIconMapping, state.currentPlane, state.geneSizeScale, (info) => showTooltip(info, elements.tooltip)));

            // Preserve pinned line layers before updating
            if (state.polygonHighlighter && state.polygonHighlighter.pinnedLineLayer) {
                layers.push(state.polygonHighlighter.pinnedLineLayer);
            }

            // Add debug dots for coordinate sanity checking
            // layers.push(createDebugDots());

            state.deckglInstance.setProps({ layers: layers });
        }

        // === PERFORMANCE-OPTIMIZED PLANE UPDATE ===
        
        // Fast update for immediate visual feedback (tiles and genes only)
        function updatePlaneImmediate(newPlane) {
            const perfStart = performance.now();
            
            const userConfig = window.config();
            const clampedPlane = clamp(newPlane, 0, userConfig.totalPlanes - 1);
            
            // Update UI immediately - no async operations
            state.currentPlane = clampedPlane;
            elements.slider.value = state.currentPlane;
            elements.label.textContent = `Plane: ${state.currentPlane}`;
            
            // Update layers immediately (tiles + genes always work, polygons use cached data if available)
            updateAllLayers();
            
            const perfTime = performance.now() - perfStart;
            const advancedConfig = window.advancedConfig();
            if (advancedConfig.performance.showPerformanceStats) {
                console.log(`‚ö° Immediate plane update: ${perfTime.toFixed(1)}ms`);
            }
        }
        
        // Background polygon loading - doesn't block UI
        async function updatePlanePolygonsAsync(planeNum) {
            const startTime = performance.now();
            
            // Skip if already cached - major performance boost
            if (state.polygonCache.has(planeNum)) {
                console.log(`Plane ${planeNum} polygons already cached - skipping load`);
                return;
            }
            
            try {
                // Show loading only for longer operations
                const loadingTimeout = setTimeout(() => {
                    if (state.currentPlane === planeNum) { // Only show if still current
                        showLoading(state, elements.loadingIndicator);
                    }
                }, 50); // Show loading after 50ms delay
                
                console.log(`Background loading polygon data for plane ${planeNum}`);
                await loadPolygonData(planeNum, state.polygonCache, state.allCellClasses, state.cellDataMap);
                
                clearTimeout(loadingTimeout);
                hideLoading(state, elements.loadingIndicator);
                
                const loadTime = performance.now() - startTime;
                console.log(`Loaded plane ${planeNum} polygons in ${loadTime.toFixed(1)}ms`);
                
                // Only update UI if this is still the current plane (user might have moved on)
                if (state.currentPlane === planeNum) {
                    // Assign colors to newly discovered cell classes
                    assignColorsToCellClasses(state.allCellClasses, state.cellClassColors);
                    
                    // Refresh layers to show new polygon data (only if still current plane)
                    updateAllLayers();
                }
                
                // Background preloading of adjacent planes
                requestIdleCallback(() => {
                    preloadAdjacentPlanes(planeNum);
                }, { timeout: 1000 });
                
            } catch (error) {
                clearTimeout(loadingTimeout);
                hideLoading(state, elements.loadingIndicator);
                console.error(`Failed to load polygon data for plane ${planeNum}:`, error);
            }
        }
        
        // Memory management for polygon cache
        function cleanupPolygonCache() {
            const now = Date.now();
            const maxCacheSize = 50; // Keep max 50 planes in memory
            const cleanupInterval = 30000; // Clean every 30 seconds
            
            // Skip if cleaned recently
            if (now - state.lastCleanupTime < cleanupInterval) {
                return;
            }
            
            if (state.polygonCache.size > maxCacheSize) {
                console.log(`Polygon cache has ${state.polygonCache.size} entries, cleaning up...`);
                
                // Keep current plane and adjacent planes
                const userConfig = window.config();
                const keepPlanes = new Set([
                    Math.max(0, state.currentPlane - 3),
                    Math.max(0, state.currentPlane - 2),
                    Math.max(0, state.currentPlane - 1),
                    state.currentPlane,
                    Math.min(userConfig.totalPlanes - 1, state.currentPlane + 1),
                    Math.min(userConfig.totalPlanes - 1, state.currentPlane + 2),
                    Math.min(userConfig.totalPlanes - 1, state.currentPlane + 3)
                ]);
                
                // Remove distant planes
                let removedCount = 0;
                for (const [plane] of state.polygonCache.entries()) {
                    if (!keepPlanes.has(plane)) {
                        state.polygonCache.delete(plane);
                        state.polygonLoadTimes.delete(plane);
                        removedCount++;
                    }
                }
                
                console.log(`Removed ${removedCount} planes from cache, ${state.polygonCache.size} remaining`);
                state.lastCleanupTime = now;
            }
        }
        
        // Smart preloading of adjacent planes
        function preloadAdjacentPlanes(currentPlane) {
            const userConfig = window.config();
            const planesToPreload = [];
            
            // Preload previous plane
            if (currentPlane > 0 && !state.polygonCache.has(currentPlane - 1)) {
                planesToPreload.push(currentPlane - 1);
            }
            
            // Preload next plane
            if (currentPlane < userConfig.totalPlanes - 1 && !state.polygonCache.has(currentPlane + 1)) {
                planesToPreload.push(currentPlane + 1);
            }
            
            // Clean up cache before preloading
            cleanupPolygonCache();
            
            // Load one at a time to avoid overwhelming the browser
            planesToPreload.forEach((plane, index) => {
                setTimeout(() => {
                    if (!state.polygonCache.has(plane)) { // Double-check it's still needed
                        console.log(`Preloading plane ${plane} in background`);
                        loadPolygonData(plane, state.polygonCache, state.allCellClasses, state.cellDataMap).catch(() => {});
                    }
                }, index * 200); // Stagger requests by 200ms
            });
        }
        
        // Main update function - now lightning fast
        function updatePlane(newPlane) {
            // No loading check needed - this is now non-blocking
            
            // Step 1: Immediate visual update (5-20ms)
            updatePlaneImmediate(newPlane);
            
            // Step 2: Load polygon data for current plane + adjacent planes immediately
            const userConfig = window.config();
            const planesToLoad = [
                Math.max(0, state.currentPlane - 1),           // Previous plane
                state.currentPlane,                            // Current plane
                Math.min(userConfig.totalPlanes - 1, state.currentPlane + 1)  // Next plane
            ];
            
            // Start loading all planes in parallel
            planesToLoad.forEach(plane => {
                if (!state.polygonCache.has(plane)) {
                    updatePlanePolygonsAsync(plane);
                }
            });
        }

        // Expose updatePlane globally for cell lookup module
        window.updatePlane = updatePlane;

        // === TOOLTIP FUNCTIONS ===
        // Tooltip functions have been moved to modules/uiHelpers.js

        // === DECK.GL INITIALIZATION ===
        function initializeDeckGL() {
            state.deckglInstance = new DeckGL({
                container: 'map',
                views: [new OrthographicView({id: 'ortho'})],
                initialViewState: INITIAL_VIEW_STATE,
                controller: {
                    minZoom: 0,
                    maxZoom: 8,
                    scrollZoom: true,
                    doubleClickZoom: true,
                    touchZoom: true,
                    keyboard: false  // Disable deck.gl keyboard to prevent conflicts
                },
                onViewStateChange: ({viewState}) => {
                    // Update scale bar when view changes
                    updateScaleBar(viewState);
                    return viewState;
                },
                onHover: (info) => {
                    console.log('Main deck.gl onHover called:', info.layer?.id, info.picked);
                    updateCoordinateDisplay(info);
                    showTooltip(info, elements.tooltip);
                },
                getCursor: ({isHovering}) => (isHovering ? 'pointer' : 'default'),
                layers: []
            });

            // Initialize scale bar with initial view state
            updateScaleBar(INITIAL_VIEW_STATE);

            // Initialize polygon highlighter - will be done after indexes are built
        }

        // === EVENT HANDLERS ===
        // Event handling functions have been moved to modules/eventHandlers.js

        // === MAIN INITIALIZATION ===
        async function init() {
            showLoading(state, elements.loadingIndicator);
            
            const userConfig = window.config();
            const advancedConfig = window.advancedConfig();
            
            // Performance optimization info
            if (advancedConfig.performance.enablePerformanceMode) {
                console.log('üöÄ Performance optimizations enabled:');
                console.log('  ‚Ä¢ Two-phase updates (immediate UI + background data)');
                console.log('  ‚Ä¢ Smart caching with automatic cleanup');
                console.log('  ‚Ä¢ Background preloading of adjacent planes');
                console.log('  ‚Ä¢ Reduced slider debouncing for instant response');
                console.log('  ‚Ä¢ Memory management (max 50 planes cached)');
            }
            
            // Clear polygon cache to ensure fresh load on app restart
            state.polygonCache.clear();
            
            // Initialize deck.gl instance and create the map container
            initializeDeckGL();
            
            // Setup all UI event listeners (slider, buttons, toggles, etc.)
            setupEventHandlers(elements, state, updatePlane, updateAllLayers);
            
            // Setup advanced keyboard shortcuts
            setupAdvancedKeyboardShortcuts(state, updatePlane, updateAllLayers);
            
            // Load gene data first - this builds the gene icon atlas and populates geneDataMap
            // Gene data is shared across all planes, so we only need to load it once
            const {atlas, mapping} = await loadGeneData(state.geneDataMap, state.selectedGenes);
            state.geneIconAtlas = atlas;
            state.geneIconMapping = mapping;
            
            // Build lightning-fast lookup indexes after gene data is loaded
            buildGeneSpotIndexes(state.geneDataMap, state.cellToSpotsIndex, state.spotToParentsIndex);
            
            // Initialize polygon highlighter with access to cell-to-spot indexes
            state.polygonHighlighter = new PolygonBoundaryHighlighter(
                state.deckglInstance,
                COORDINATE_SYSTEM.CARTESIAN,
                state.cellToSpotsIndex,
                state.geneToId,
                state.cellDataMap
            );
            state.polygonHighlighter.initialize();
            
            // Load cell data - this is also shared across all planes
            console.log('Loading cell data...');
            await loadCellData(state.cellDataMap);
            
            // CRITICAL FIX: Load polygon data for current plane + adjacent planes during initialization
            // This prevents flickering on the very first slider movement
            console.log(`Init: Loading polygon data for plane ${state.currentPlane} + adjacent planes`);
            
            // Load current plane first (blocking)
            const polygonResult = await loadPolygonData(state.currentPlane, state.polygonCache, state.allCellClasses, state.cellDataMap);
            console.log(`Init: Current plane polygon data loaded:`, polygonResult);
            
            // Assign colors to cell classes after loading polygon data
            assignColorsToCellClasses(state.allCellClasses, state.cellClassColors);
            
            // Initialize cell class widget with all classes selected by default
            if (state.selectedCellClasses.size === 0) {
                state.allCellClasses.forEach(cellClass => state.selectedCellClasses.add(cellClass));
            }
            
            // Preload adjacent planes (non-blocking)
            const adjacentPlanes = [
                Math.max(0, state.currentPlane - 1),
                Math.min(userConfig.totalPlanes - 1, state.currentPlane + 1)
            ];
            
            adjacentPlanes.forEach(async (plane) => {
                if (plane !== state.currentPlane && !state.polygonCache.has(plane)) {
                    console.log(`Init: Preloading polygon data for adjacent plane ${plane}`);
                    loadPolygonData(plane, state.polygonCache, state.allCellClasses, state.cellDataMap).catch(() => {
                        console.log(`Init: Failed to preload plane ${plane} (non-critical)`);
                    });
                }
            });
            
            // Update UI to reflect the current plane state after data loading
            state.currentPlane = DEFAULT_STATE.currentPlane;
            elements.slider.min = 0;
            elements.slider.max = userConfig.totalPlanes - 1;
            elements.slider.value = state.currentPlane;
            elements.label.textContent = `Plane: ${state.currentPlane}`;
            
            // Now safely update all layers - all required data (genes, polygons) is loaded
            // This will render: background tiles + gene markers + cell boundary polygons
            updateAllLayers();
            
            hideLoading(state, elements.loadingIndicator);
            
            if (advancedConfig.performance.showPerformanceStats) {
                console.log('‚úÖ Initialization complete. Slider should now be very responsive!');
            }
        }

        // Initialize cell lookup UI immediately when page loads (before data loading)
        window.addEventListener('load', () => {
            // Initialize cell lookup UI first - this sets up the Ctrl+F event listener
            if (window.cellLookup) {
                window.cellLookup.setupUI();
                console.log('üîç Cell lookup UI ready immediately (data will load on first search)');
            }
            
            // Then start the main application initialization
            init();
        });
    </script>
</body>
</html>