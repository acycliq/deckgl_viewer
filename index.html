<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>deck.gl Gene TSV viewer</title>
  <style>
    html, body {
      margin:0;
      height:100%;
      font-family: Arial,Helvetica,sans-serif;
    }
    #root {
      position: relative;
      width:100%;
      height:100%;
      background-color: #000;
      color: #fff;
    }
    #deck-canvas {
      position:absolute;
      top:0;
      left:0;
      right:0;
      bottom:48px;
      background-color: #000;
    }
    #controls {
      position:absolute;
      left:0;
      right:0;
      bottom:0;
      height:48px;
      display:flex;
      align-items:center;
      padding:4px 8px;
      background:rgba(0,0,0,0.8);
      border-top:1px solid #444;
      gap:8px;
    }
    #controls label, #controls span {
      color:#fff;
    }
    input[type=range] {
      flex:1;
      background:transparent;
    }
    #tooltip {
      position:absolute;
      pointer-events:none;
      background:rgba(0,0,0,0.75);
      color:#fff;
      padding:6px;
      border-radius:4px;
      font-size:12px;
      display:none;
      white-space:nowrap;
      z-index:1000;
    }
  </style>
</head>
<body>
  <div id="root">
    <div id="deck-canvas"></div>
    <div id="controls">
      <label>Plane:</label>
      <span id="planeValue">0</span>
      <input id="planeSlider" type="range" min="0" max="0" step="1" value="0" />
    </div>
    <div id="tooltip"></div>
  </div>

  <!-- external glyph scripts -->
  <script src="glyphPaths.js"></script>
  <script src="glyphConfig.js"></script>
  <!-- libraries -->
  <script src="https://unpkg.com/deck.gl@^8.9.0/dist.min.js"></script>
  <script src="https://unpkg.com/d3-dsv@3"></script>
  <script src="https://unpkg.com/d3-array@3"></script>
  <!-- Note: Full d3.js or d3-color is not needed for this optimized version -->

  <script>
    // --- App Configuration ---
    const DATA_URL = 'data/geneData.tsv';

    // --- Load config and create mappings ---
    const settings = glyphSettings();
    const configMap = new Map(settings.map(s => [s.gene, {glyphName:s.glyphName, color:s.color}]));
    const defaultConfig = configMap.get('Generic') || {glyphName:'circle', color:'#ffffff'};

    // --- Global State ---
    let data = [];
    let genes = [];
    let plane = 0;
    let iconAtlas = null;
    let iconMapping = null;

    // --- Atlas Generation (High-Performance Version) ---
    // This function bakes the final colors directly into the atlas texture.
    function buildAtlas(list) {
      const size=64;
      const canvas=document.createElement('canvas');
      canvas.width=size*list.length;
      canvas.height=size;
      const ctx=canvas.getContext('2d');
      const mapping={};
      list.forEach((gene, i) => {
        const cfg = configMap.get(gene) || defaultConfig;
        const p = {x: i * size + size / 2, y: size / 2};
        const r = size * 0.4;
        ctx.save();
        // Set the final color here. The canvas context accepts hex strings.
        ctx.strokeStyle = cfg.color;
        ctx.lineWidth = 2;
        ctxPath(cfg.glyphName, ctx, p, r);
        ctx.stroke();
        ctx.restore();
        // The mapping is simpler now, no 'mask' needed.
        mapping[gene] = {x: i * size, y: 0, width: size, height: size};
      });
      return {atlas: canvas, mapping};
    }

    // --- Deck.gl Initialization ---
    const {IconLayer, OrthographicView, COORDINATE_SYSTEM} = deck;
    const deckgl = new deck.Deck({
      parameters: {clearColor: [0, 0, 0, 1]},
      parent: document.getElementById('deck-canvas'),
      views: new OrthographicView({controller:true}),
      initialViewState: {target: [0,0,0], zoom: 0, minZoom: -5, maxZoom: 10},
      layers: []
    });

    // --- Interactivity Callbacks ---
    const tooltip = document.getElementById('tooltip');
    function onHover({x, y, object}){
      if (object) {
        tooltip.style.display = 'block';
        tooltip.style.left = x + 5 + 'px';
        tooltip.style.top = y + 5 + 'px';
        tooltip.innerHTML =
          `<strong>Gene:</strong> ${object.gene}<br>`+
          `<strong>Coords:</strong> ${object.x.toFixed(2)}, ${object.y.toFixed(2)}<br>`+
          `<strong>Plane:</strong> ${object.z}`;
      } else {
        tooltip.style.display = 'none';
      }
    }

    // --- Core Render Function ---
    function updateLayer() {
      deckgl.setProps({layers: [
        new IconLayer({
          id: 'spots',
          data,
          pickable: true,
          onHover,
          coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
          iconAtlas,
          iconMapping,
          getPosition: d => [d.x, -d.y],
          getSize: d => 20 / Math.sqrt(1 + Math.abs(d.z - plane)),
          getIcon: d => d.gene,
          // Use a constant color. The real color is in the atlas texture.
          // This is the key to high performance.
          getColor: [255, 255, 255],
          sizeUnits: 'pixels',
          sizeScale: 1,
          updateTriggers: {
            getSize: [plane]
          }
        })
      ]});
    }

    // --- UI Event Listeners ---
    document.getElementById('planeSlider').addEventListener('input', e => {
      plane = Number(e.target.value);
      document.getElementById('planeValue').textContent = plane;
      updateLayer();
    });

    // --- Data Loading and App Start ---
    async function run() {
      try {
        const response = await fetch(DATA_URL);
        const txt = await response.text();

        data = d3.tsvParse(txt, d => ({
          x: +d.x, y: +d.y, z: +d.plane_id, gene: d.gene_name
        }));

        genes = Array.from(new Set(data.map(d => d.gene)));

        const zExt = d3.extent(data, d => d.z);
        const slider = document.getElementById('planeSlider');
        slider.min = zExt[0]; slider.max = zExt[1];
        plane = slider.value = zExt[0];
        document.getElementById('planeValue').textContent = plane;

        const atlasInfo = buildAtlas(genes);
        iconAtlas = atlasInfo.atlas;
        iconMapping = atlasInfo.mapping;

        const xExt = d3.extent(data, d => d.x);
        const yExt = d3.extent(data, d => d.y);
        const centerX = (xExt[0] + xExt[1]) / 2;
        const centerY = -(yExt[0] + yExt[1]) / 2;
        const canvas = deckgl.canvas;
        const zoom = Math.log2(Math.min(
            canvas.clientWidth / (xExt[1] - xExt[0]),
            canvas.clientHeight / (yExt[1] - yExt[0])
        ));

        deckgl.setProps({
            initialViewState: {target: [centerX, centerY, 0], zoom, minZoom: -5, maxZoom: 10}
        });

        updateLayer();
      } catch (error) {
        console.error('Failed to load or process data:', error);
      }
    }

    run();
  </script>
</body>
</html>